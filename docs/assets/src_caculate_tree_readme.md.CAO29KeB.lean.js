import{_ as a,c as r,a0 as l,o as i}from"./chunks/framework.CroFxgLA.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/caculate/tree/readme.md","filePath":"src/caculate/tree/readme.md","lastUpdated":null}'),t={name:"src/caculate/tree/readme.md"};function o(s,e,n,h,d,c){return i(),r("div",null,e[0]||(e[0]=[l('<h2 id="二叉树" tabindex="-1">二叉树 <a class="header-anchor" href="#二叉树" aria-label="Permalink to &quot;二叉树&quot;">​</a></h2><blockquote><p>每一个节点最多不超过2的树</p></blockquote><h3 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h3><ul><li><p>1.叶子节点,没有子节点的节点</p></li><li><p>2.度,至少含有一个节点的节点</p></li><li><p>1.一个二叉树的第(i)层最大拥有2^(i-1)个节点,i&gt;=1</p></li><li><p>2.深度为k的二叉树最多有 2^k-1个节点,k&gt;=1</p></li><li><p>3.对于任意非空二叉树,n0表示叶子节点的个数,n2表示度为2的非叶子节点的个数 n0=n2+1</p></li></ul><h2 id="二叉搜索树-barnyar-serch-tree" tabindex="-1">二叉搜索树 barnyar serch tree <a class="header-anchor" href="#二叉搜索树-barnyar-serch-tree" aria-label="Permalink to &quot;二叉搜索树 barnyar serch tree&quot;">​</a></h2><ul><li>左节点小于父节点</li><li>右节点大于父节点</li><li>左右节点满足二叉搜索树</li></ul><p>特点</p><ul><li>1.较小的元素在树的左边</li><li>2.较大的元素在树的右边</li></ul><h2 id="常用的方法" tabindex="-1">常用的方法 <a class="header-anchor" href="#常用的方法" aria-label="Permalink to &quot;常用的方法&quot;">​</a></h2><h3 id="insert-key-添加操作" tabindex="-1">insert(key)添加操作 <a class="header-anchor" href="#insert-key-添加操作" aria-label="Permalink to &quot;insert(key)添加操作&quot;">​</a></h3><h3 id="search-key-查找" tabindex="-1">search(key) 查找 <a class="header-anchor" href="#search-key-查找" aria-label="Permalink to &quot;search(key) 查找&quot;">​</a></h3><h3 id="inordertraverse-中序遍历法遍历所有节点" tabindex="-1">inOrderTraverse 中序遍历法遍历所有节点 <a class="header-anchor" href="#inordertraverse-中序遍历法遍历所有节点" aria-label="Permalink to &quot;inOrderTraverse 中序遍历法遍历所有节点&quot;">​</a></h3><h3 id="preordertraverse-先序遍历法遍历所有节点" tabindex="-1">preOrderTraverse 先序遍历法遍历所有节点 <a class="header-anchor" href="#preordertraverse-先序遍历法遍历所有节点" aria-label="Permalink to &quot;preOrderTraverse 先序遍历法遍历所有节点&quot;">​</a></h3><h3 id="postordertraverse-后续遍历法遍历所有节点" tabindex="-1">postOrderTraverse 后续遍历法遍历所有节点 <a class="header-anchor" href="#postordertraverse-后续遍历法遍历所有节点" aria-label="Permalink to &quot;postOrderTraverse 后续遍历法遍历所有节点&quot;">​</a></h3><h3 id="min-最小值" tabindex="-1">min() 最小值 <a class="header-anchor" href="#min-最小值" aria-label="Permalink to &quot;min() 最小值&quot;">​</a></h3><h3 id="max-最大值" tabindex="-1">max() 最大值 <a class="header-anchor" href="#max-最大值" aria-label="Permalink to &quot;max() 最大值&quot;">​</a></h3><h3 id="remove-key-删除" tabindex="-1">remove(key) 删除 <a class="header-anchor" href="#remove-key-删除" aria-label="Permalink to &quot;remove(key) 删除&quot;">​</a></h3><ul><li><ol><li>没有找到key</li></ol></li><li><ol start="2"><li>找到了key</li></ol><ul><li>2.1 没有子节点</li><li>2.2 有一个子节点</li><li>2.3 有两个子节点 <ul><li>2.3.1 左子树的最大值替换要删除的节点</li><li>2.3.2 右子树的最小值替换要删除的节点</li></ul></li></ul></li></ul>',18)]))}const p=a(t,[["render",o]]);export{m as __pageData,p as default};
